<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Modified Heapsort for Descending Order (Min-Heap)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.5;
      margin: 20px;
    }
    h2, h3 {
      margin-top: 1em;
      margin-bottom: 0.5em;
    }
    pre {
      background: #f4f4f4;
      padding: 10px;
      border: 1px solid #ccc;
      font-family: "Courier New", monospace;
    }
    .boxed {
      border: 1px solid #ccc;
      background: #f9f9f9;
      padding: 8px;
      margin: 8px 0;
      font-family: "Courier New", monospace;
    }
    ul {
      margin-left: 20px;
    }
  </style>
</head>
<body>

<h2>Modified Heapsort: Descending Order Using a Min‑Heap</h2>

<h3>1. Modified Pseudocode</h3>
<p>The standard Heapsort based on a max‑heap produces an ascending sorted array. To sort in <strong>descending order</strong>, we build a <strong>min‑heap</strong> so that the smallest element is at the root. We then repeatedly swap the root with the last element in the heap and call MIN‑HEAPIFY to restore the min‑heap property. This places the smallest element at the end; after all iterations, the array is in descending order.</p>

<p><strong>MIN‑HEAPIFY</strong> (modified from MAX‑HEAPIFY):</p>
<pre>
MIN-HEAPIFY(A, i)
1.  l = LEFT(i)          // left child index of i
2.  r = RIGHT(i)         // right child index of i
3.  if l ≤ A.heap_size and A[l] < A[i]
4.      smallest = l
5.  else
6.      smallest = i
7.  if r ≤ A.heap_size and A[r] < A[smallest]
8.      smallest = r
9.  if smallest ≠ i
10.     exchange A[i] with A[smallest]
11.     MIN-HEAPIFY(A, smallest)
</pre>

<p><strong>BUILD‑MIN‑HEAP</strong>:</p>
<pre>
BUILD-MIN-HEAP(A)
1.  A.heap_size = length[A]
2.  for i = ⌊length[A] / 2⌋ downto 1
3.      MIN-HEAPIFY(A, i)
</pre>

<p><strong>HEAPSORT (using min‑heap for descending order)</strong>:</p>
<pre>
HEAPSORT-DESCENDING(A)
1.  BUILD-MIN-HEAP(A)
2.  for i = length[A] downto 2
3.      exchange A[1] with A[i]
4.      A.heap_size = A.heap_size - 1
5.      MIN-HEAPIFY(A, 1)
</pre>

<h3>2. Time Complexity Discussion</h3>
<ul>
  <li>Both the original max‑heap Heapsort and the modified min‑heap version run in O(n log n) time.</li>
  <li>Building the heap takes O(n) time in both cases.</li>
  <li>The extraction loop performs O(n) iterations with each MIN‑HEAPIFY taking O(log n) in the worst case.</li>
  <li>Thus, overall, the time complexity remains O(n log n).</li>
</ul>

<h3>3. Step-by-Step Execution on the Input List</h3>
<p>We use 1‑based indexing for the array:</p>
<div class="boxed">
A = [15, 3, 9, 20, 7, 2, 18, 5, 12]
</div>
<p>Initial heap_size = 9.</p>

<h4>Phase 1: Build-Min-Heap</h4>
<ul>
  <li><strong>i = ⌊9/2⌋ = 4</strong>: 
    <ul>
      <li>A[4] = 20; children: A[8] = 5, A[9] = 12.</li>
      <li>Minimum among {20, 5, 12} is 5 (at index 8).</li>
      <li>Swap A[4] and A[8]:
        <div class="boxed">A = [15, 3, 9, 5, 7, 2, 18, 20, 12]</div>
      </li>
      <li>Call MIN‑HEAPIFY(A,8): index 8=20 has no children; done.</li>
    </ul>
  </li>
  <li><strong>i = 3</strong>:
    <ul>
      <li>A[3] = 9; children: A[6] = 2, A[7] = 18.</li>
      <li>Minimum among {9, 2, 18} is 2 (at index 6).</li>
      <li>Swap A[3] and A[6]:
        <div class="boxed">A = [15, 3, 2, 5, 7, 9, 18, 20, 12]</div>
      </li>
      <li>Call MIN‑HEAPIFY(A,6): index 6=9 has no children; done.</li>
    </ul>
  </li>
  <li><strong>i = 2</strong>:
    <ul>
      <li>A[2] = 3; children: A[4] = 5, A[5] = 7.</li>
      <li>Minimum among {3, 5, 7} is 3; no swap.</li>
    </ul>
  </li>
  <li><strong>i = 1</strong>:
    <ul>
      <li>A[1] = 15; children: A[2] = 3, A[3] = 2.</li>
      <li>Minimum among {15, 3, 2} is 2 (at index 3).</li>
      <li>Swap A[1] and A[3]:
        <div class="boxed">A = [2, 3, 15, 5, 7, 9, 18, 20, 12]</div>
      </li>
      <li>Call MIN‑HEAPIFY(A,3):
        <ul>
          <li>At index 3: A[3] = 15; children: A[6] = 9, A[7] = 18.</li>
          <li>Minimum among {15, 9, 18} is 9 (at index 6).</li>
          <li>Swap A[3] and A[6]:
            <div class="boxed">A = [2, 3, 9, 5, 7, 15, 18, 20, 12]</div>
          </li>
          <li>Call MIN‑HEAPIFY(A,6): index 6=15 has no children; done.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<div class="boxed">
<strong>After Build-Min-Heap:</strong><br>
A = [2, 3, 9, 5, 7, 15, 18, 20, 12]
</div>

<h4>Phase 2: Heapsort Extraction (Descending Order)</h4>
<p>We now repeatedly swap the minimum (A[1]) with A[i], decrease the heap, and call MIN‑HEAPIFY(A,1).</p>

<ul>
  <li><strong>Iteration 1 (i = 9):</strong>
    <ul>
      <li>Swap A[1] and A[9]: swap 2 and 12.
        <div class="boxed">A = [12, 3, 9, 5, 7, 15, 18, 20, 2]</div>
      </li>
      <li>Set heap_size = 8; Call MIN‑HEAPIFY(A,1):
        <ul>
          <li>At index 1: A[1] = 12; children: A[2] = 3, A[3] = 9; minimum is 3 (index 2).</li>
          <li>Swap A[1] and A[2]:
            <div class="boxed">A = [3, 12, 9, 5, 7, 15, 18, 20, 2]</div>
          </li>
          <li>Call MIN‑HEAPIFY(A,2): index 2=12; children: A[4]=5, A[5]=7; minimum is 5 (index 4).
            <ul>
              <li>Swap A[2] and A[4]:
                <div class="boxed">A = [3, 5, 9, 12, 7, 15, 18, 20, 2]</div>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Array after Iteration 1: [3, 5, 9, 12, 7, 15, 18, 20, 2]</li>
    </ul>
  </li>
  <li><strong>Iteration 2 (i = 8):</strong>
    <ul>
      <li>Swap A[1] and A[8]: swap 3 and 20.
        <div class="boxed">A = [20, 5, 9, 12, 7, 15, 18, 3, 2]</div>
      </li>
      <li>Set heap_size = 7; Call MIN‑HEAPIFY(A,1):
        <ul>
          <li>Index 1: A[1] = 20; children: A[2]=5, A[3]=9; minimum is 5 (index 2).</li>
          <li>Swap A[1] and A[2]:
            <div class="boxed">A = [5, 20, 9, 12, 7, 15, 18, 3, 2]</div>
          </li>
          <li>Call MIN‑HEAPIFY(A,2): index 2=20; children: A[4]=12, A[5]=7; minimum is 7 (index 5).
            <ul>
              <li>Swap A[2] and A[5]:
                <div class="boxed">A = [5, 7, 9, 12, 20, 15, 18, 3, 2]</div>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Array after Iteration 2: [5, 7, 9, 12, 20, 15, 18, 3, 2]</li>
    </ul>
  </li>
  <li><strong>Iteration 3 (i = 7):</strong>
    <ul>
      <li>Swap A[1] and A[7]: swap 5 and 18.
        <div class="boxed">A = [18, 7, 9, 12, 20, 15, 5, 3, 2]</div>
      </li>
      <li>Set heap_size = 6; Call MIN‑HEAPIFY(A,1):
        <ul>
          <li>Index 1: A[1] = 18; children: A[2]=7, A[3]=9; minimum is 7 (index 2).</li>
          <li>Swap A[1] and A[2]:
            <div class="boxed">A = [7, 18, 9, 12, 20, 15, 5, 3, 2]</div>
          </li>
          <li>Call MIN‑HEAPIFY(A,2): index 2=18; children: A[4]=12, A[5]=20; minimum is 12 (index 4).
            <ul>
              <li>Swap A[2] and A[4]:
                <div class="boxed">A = [7, 12, 9, 18, 20, 15, 5, 3, 2]</div>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Array after Iteration 3: [7, 12, 9, 18, 20, 15, 5, 3, 2]</li>
    </ul>
  </li>
  <li><strong>Iteration 4 (i = 6):</strong>
    <ul>
      <li>Swap A[1] and A[6]: swap 7 and 15.
        <div class="boxed">A = [15, 12, 9, 18, 20, 7, 5, 3, 2]</div>
      </li>
      <li>Set heap_size = 5; Call MIN‑HEAPIFY(A,1):
        <ul>
          <li>Index 1: A[1] = 15; children: A[2]=12, A[3]=9; minimum is 9 (index 3).</li>
          <li>Swap A[1] and A[3]:
            <div class="boxed">A = [9, 12, 15, 18, 20, 7, 5, 3, 2]</div>
          </li>
          <li>Call MIN‑HEAPIFY(A,3): index 3=15 has no children (heap_size = 5); done.</li>
        </ul>
      </li>
      <li>Array after Iteration 4: [9, 12, 15, 18, 20, 7, 5, 3, 2]</li>
    </ul>
  </li>
  <li><strong>Iteration 5 (i = 5):</strong>
    <ul>
      <li>Swap A[1] and A[5]: swap 9 and 20.
        <div class="boxed">A = [20, 12, 15, 18, 9, 7, 5, 3, 2]</div>
      </li>
      <li>Set heap_size = 4; Call MIN‑HEAPIFY(A,1):
        <ul>
          <li>Index 1: A[1] = 20; children: A[2]=12, A[3]=15; minimum is 12 (index 2).</li>
          <li>Swap A[1] and A[2]:
            <div class="boxed">A = [12, 20, 15, 18, 9, 7, 5, 3, 2]</div>
          </li>
        </ul>
      </li>
      <li>Array after Iteration 5: [12, 20, 15, 18, 9, 7, 5, 3, 2]</li>
    </ul>
  </li>
  <li><strong>Iteration 6 (i = 4):</strong>
    <ul>
      <li>Swap A[1] and A[4]: swap 12 and 18.
        <div class="boxed">A = [18, 20, 15, 12, 9, 7, 5, 3, 2]</div>
      </li>
      <li>Set heap_size = 3; Call MIN‑HEAPIFY(A,1):
        <ul>
          <li>Index 1: A[1] = 18; children: A[2]=20, A[3]=15; minimum is 15 (index 3).</li>
          <li>Swap A[1] and A[3]:
            <div class="boxed">A = [15, 20, 18, 12, 9, 7, 5, 3, 2]</div>
          </li>
        </ul>
      </li>
      <li>Array after Iteration 6: [15, 20, 18, 12, 9, 7, 5, 3, 2]</li>
    </ul>
  </li>
  <li><strong>Iteration 7 (i = 3):</strong>
    <ul>
      <li>Swap A[1] and A[3]: swap 15 and 18.
        <div class="boxed">A = [18, 20, 15, 12, 9, 7, 5, 3, 2]</div>
      </li>
      <li>Set heap_size = 2; Call MIN‑HEAPIFY(A,1):
        <ul>
          <li>Index 1: A[1] = 18; only child A[2] = 20; minimum is 18 (no swap needed as 18 ≤ 20).</li>
        </ul>
      </li>
      <li>Array after Iteration 7: [18, 20, 15, 12, 9, 7, 5, 3, 2]</li>
    </ul>
  </li>
  <li><strong>Iteration 8 (i = 2):</strong>
    <ul>
      <li>Swap A[1] and A[2]: swap 18 and 20.
        <div class="boxed">A = [20, 18, 15, 12, 9, 7, 5, 3, 2]</div>
      </li>
      <li>Heap size becomes 1; sorting complete.</li>
    </ul>
  </li>
</ul>

<div class="boxed">
<strong>Final Sorted Array (Descending Order):</strong><br>
20, 18, 15, 12, 9, 7, 5, 3, 2
</div>

</body>
</html>
